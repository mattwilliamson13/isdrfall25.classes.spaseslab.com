{
  "hash": "8b136c70daef9224d575172df162c09d",
  "result": {
    "markdown": "---\ntitle: \"Data Structures\"\ndate: \"2023-9-1\"\n---\n\n\n## Data Types and Structures\n\n### Data Types\nOkay, now that we have all of those details out of the way, let's take a look at data structures in `R`. As we discussed,`R` has six basic types of data: numeric, integer, logical, complex, character, and raw. For this class, we won't bother with complex or raw as you are unlikely to encounter them in your introductory spatial explorations.\n\n* __Numeric__ data are numbers that contain a decimal. They can also be whole numbers\n\n* __Integers__ are whole numbers (those numbers without a decimal point). \n\n* __Logical__ data take on the value of either `TRUE` or `FALSE`. Thereâ€™s also another special type of logical called `NA` to represent missing values.\n\n* __Character data__ represent string values. You can think of character strings as something like a word (or multiple words). A special type of character string is a factor, which is a string but with additional attributes (like levels or an order). Factors become important in the analyses and visualizations we'll attempt later in the course.\n\nThere are a variety of ways to learn more about the structure of different data types:\n\n* `class()` - returns the type of object (high level)\n* `typeof()` - returns the type of object (low level)\n* `length()` tells you about the length of an object\n* `attributes()` - does the object have any metadata\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum <- 2.2\nclass(num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ny <- 1:10 \ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nlength(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nb <- \"3\"\nclass(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nis.numeric(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nc <- as.numeric(b)\nclass(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n### Data Structures\nYou can store information in a variety of ways in `R`. The types we are most likely to encounter this semester are:\n\n* __Vectors__: a collection of elements that are typically `character`, `logical`, `integer`, or `numeric`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#sometimes we'll need to make sequences of numbers to facilitate joins\nseries <- 1:10\nseries.2 <- seq(10)\nseries.3 <- seq(from = 1, to = 10, by = 0.1)\nseries\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nseries.2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nseries.3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4\n[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9\n[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4\n[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9\n[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4\n[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9\n[91] 10.0\n```\n:::\n\n```{.r .cell-code}\nc(series.2, series.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1]  1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0  9.0 10.0  1.0  1.1  1.2  1.3  1.4\n [16]  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4  2.5  2.6  2.7  2.8  2.9\n [31]  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9  4.0  4.1  4.2  4.3  4.4\n [46]  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9\n [61]  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4\n [76]  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9\n [91]  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9 10.0\n```\n:::\n\n```{.r .cell-code}\nclass(series.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(series.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nlength(series.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 91\n```\n:::\n:::\n\n    \n  * Missing Data: R supports missing data in most of the data structures we use, but they can lead to some strange behaviors. Here are a few ways to find missing data:\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", NA, \"c\", \"d\", NA)\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nanyNA(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n  \n* __Matrices__: are an extension of the numeric or character vectors. They are not a separate type of object but simply an atomic vector with dimensions; the number of rows and columns. As with atomic vectors, the _elements of a matrix must be of the same data_. Matrices are the foundation of rasters, which we'll be discussing frequently throughout the course\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#matrices are filled columnwise in R\nm <- matrix(1:6, nrow = 2, ncol = 3)\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nx <- 1:3\ny <- 10:12\n\na <- cbind(x, y)\ndim(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2\n```\n:::\n\n```{.r .cell-code}\na[3,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx \n3 \n```\n:::\n\n```{.r .cell-code}\nb <- rbind(x, y)\ndim(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nb[1,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx \n3 \n```\n:::\n:::\n\n\n\n\n* __Lists__: Lists essentially act like containers in `R` - they can hold a variety of different data types and structures including more lists. We use lists a lot for functional programming in R where we can apply a function to each element in a list. We'll see this with extracting values from multiple rasters. We can extract elements of lists usin `[]` and `[[]]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1, \"a\", TRUE, 1+4i)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n[[4]]\n[1] 1+4i\n```\n:::\n\n```{.r .cell-code}\n#adding names\nxlist <- list(a = \"Waldo\", b = 1:10, data = head(mtcars))\nxlist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] \"Waldo\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n\n```{.r .cell-code}\nxlist[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Waldo\"\n```\n:::\n\n```{.r .cell-code}\nxlist[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n\n```{.r .cell-code}\nxlist[[3]][1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg\nMazda RX4         21.0\nMazda RX4 Wag     21.0\nDatsun 710        22.8\nHornet 4 Drive    21.4\nHornet Sportabout 18.7\nValiant           18.1\n```\n:::\n\n```{.r .cell-code}\nxlist[[3]][1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nxlist[3][1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n:::\n\n\n* __Data Frames__: data frames resemble that tabular datasets you might be used to in spreadsheet programs and are probably one of the most common types of data in `R`. A data frame is a special type of list where every element has the same length (but can have different types of data). We'll be reading in a number of data frames for this first assignment. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(id = letters[1:10], x = 1:10, y = 11:20)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   id  x  y\n1   a  1 11\n2   b  2 12\n3   c  3 13\n4   d  4 14\n5   e  5 15\n6   f  6 16\n7   g  7 17\n8   h  8 18\n9   i  9 19\n10  j 10 20\n```\n:::\n\n```{.r .cell-code}\nis.list(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nclass(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\n#lots of ways to look at data in data frames\nstr(dat) #compact summary of the structure of a dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t10 obs. of  3 variables:\n $ id: chr  \"a\" \"b\" \"c\" \"d\" ...\n $ x : int  1 2 3 4 5 6 7 8 9 10\n $ y : int  11 12 13 14 15 16 17 18 19 20\n```\n:::\n\n```{.r .cell-code}\nhead(dat) #gives the first 6 rows similar to tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id x  y\n1  a 1 11\n2  b 2 12\n3  c 3 13\n4  d 4 14\n5  e 5 15\n6  f 6 16\n```\n:::\n\n```{.r .cell-code}\ndim(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10  3\n```\n:::\n\n```{.r .cell-code}\ncolnames(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"id\" \"x\"  \"y\" \n```\n:::\n\n```{.r .cell-code}\n## accessing elements of a dataframe\ndat[1,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n\n```{.r .cell-code}\ndat[[\"y\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11 12 13 14 15 16 17 18 19 20\n```\n:::\n\n```{.r .cell-code}\ndat$y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11 12 13 14 15 16 17 18 19 20\n```\n:::\n:::\n\n\n* __Tibbles__: are similar to data frames, but allow for lists _within_ columns. They are designed for use with the `tidyverse` (which we'll explore more in future classes), but the primary reason for introducing them here is because they are the foundation of `sf` objects which we'll use frequently in the weeks to come.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.4     âœ” readr     2.1.5\nâœ” forcats   1.0.0     âœ” stringr   1.5.1\nâœ” ggplot2   3.5.1     âœ” tibble    3.2.1\nâœ” lubridate 1.9.3     âœ” tidyr     1.3.1\nâœ” purrr     1.0.2     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\nâ„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\ndat.tib <- tibble(dat)\nis.list(dat.tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nclass(dat.tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\n#lots of ways to look at data in data frames\nstr(dat.tib) #compact summary of the structure of a dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [10 Ã— 3] (S3: tbl_df/tbl/data.frame)\n $ id: chr [1:10] \"a\" \"b\" \"c\" \"d\" ...\n $ x : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ y : int [1:10] 11 12 13 14 15 16 17 18 19 20\n```\n:::\n\n```{.r .cell-code}\nhead(dat.tib) #gives the first 6 rows similar to tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 3\n  id        x     y\n  <chr> <int> <int>\n1 a         1    11\n2 b         2    12\n3 c         3    13\n4 d         4    14\n5 e         5    15\n6 f         6    16\n```\n:::\n\n```{.r .cell-code}\ndim(dat.tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10  3\n```\n:::\n\n```{.r .cell-code}\ncolnames(dat.tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"id\" \"x\"  \"y\" \n```\n:::\n\n```{.r .cell-code}\n## accessing elements of a dataframe\ndat.tib[1,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 Ã— 1\n      y\n  <int>\n1    11\n```\n:::\n\n```{.r .cell-code}\ndat.tib[[\"y\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11 12 13 14 15 16 17 18 19 20\n```\n:::\n\n```{.r .cell-code}\ndat.tib$y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11 12 13 14 15 16 17 18 19 20\n```\n:::\n:::\n\n\nMany of the packages used for spatial operations in `R` rely on special objects (e.g., `sf`, `SpatRasters`) that are combinations of these various elemental data types. That is why we are taking a little time to understand them before jumping into spatial data.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}